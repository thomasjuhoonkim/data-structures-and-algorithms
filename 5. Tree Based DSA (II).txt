B-tree:
    https://www.programiz.com/dsa/b-tree
    - B-tree is a special type of self-balancing search tree in which each node can contain
      more than one key and can have more than two children.
    - It is a generalized form of the binary search tree.
    - Also known as a height-balanced m-way tree.
    Why do you need a B-tree data structure?:
        - The need for B-tree arose with the rise in the need for lesser time in accessing
          the physical storage media like a hard disk.
        - The secondary storage devices are slower with a larger capacity.
        - There was a need for such types of data structrues that minimize the disk accesses.
        - Other data structures succh as a binary search tree, avl tree, red-black tree, etc can
          store only one key in one node.
        - If you have to store a large number of keys, then the height of such trees becomes very
          large and the access time increases.
        - However, as B-tree can store many keys in a single node and can have multiple child nodes.
        - This dereases the height significantly allowing faster disk accesses.
    
    B-tree Properties:
        1. For each node x, the keys are stores in increasing order.
        2. In each node, there is a boolean value x.leaf which is true if x is a leaf.
        3. If n is the order of the tree, each internal node can contain at most n - 1 keys
           along with a pointer to each child.
        4. Each node except root can have at most n children and at least n/2 children.
        5. All leaves have the same depth (height-h of the tree).
        6. The root has at least 2 children and contains a minimum of 1 key.
        7. If n >= 1, then for any n-key B-tree of height h and minimum degree t >= 2,
           h >= logt (n+1)/2.
    
    Opeartions on a B-tree:
        Searching an element in a B-tree:
            - Searching for an element in a B-tree is the generalized form of searching an element
              in a Binary Search Tree.
            1. Starting from the root node, compare k with the first key of the node.
               If k = the first ke of the node, return the node and the index.
            2. If k.leaf = true, return NULL (i.e. not found).
            3. If k < the first key of the root node, search the left child of this key recursively.
            4. If there is more than one key in the current node and k > the first key,
               compare k with the next key in the node.
               If k < next key, search the left child of this key (ie. k lies in between the first
               and second keys).
               Else, search the right child of the key.
            5. Repeat steps 1 to 4 until the leaf is reached.
    
    Algorithm for Searching an Element:
        BtreeSearch(x, k)
            i = 1
            while i ≤ n[x] and k ≥ keyi[x]        // n[x] means number of keys in x node
                do i = i + 1
            if i  n[x] and k = keyi[x]
                then return (x, i)
            if leaf [x]
                then return NIL
            else
                return BtreeSearch(ci[x], k)
    
    B-tree opeations code: example files

    Searching Complexity on B Tree:
        Worst case Time Complexity: Theta(log n)
        Average case Time complexity: Theta(log n)
        Best case Time Complexity: Theta(log n)
        Average case Space complexity: Theta(n)
        Worst case Space complexity: Theta(n)
    
    B Tree Applications:
        - Databases and file systems
        - To store blocks of data (secondary storage media)
        - Multilevel indexing

========================================================================================

