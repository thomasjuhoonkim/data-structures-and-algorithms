Greedy Algorithm:
    - A greedy algorithm is an appraoch for solving a problem by selecting the best option available
      at the moment. It doesn't worry whether the current best result will bring the overall optimal
      result.
    - The algorithm never reverses the earlier decision even if the choice is wrong. It works in a 
      top-down approach.
    - This algorithm may not produce the best result for all the problems. It's because it always
      goes for the local best choice to produce the global best result.
    - However, we can determine if the algorithm can be used with any problem if the problem has
      the following properties.
    1. Greedy Choice property
        - If an optimal solution to the problem can be found by choosing the best choice at each step
          without reconsidering the previous stes once chosen, the problem can be solved using a
          greedy approach. This property is called greedy choice property.
    2. Optimal Substructure:
        - If the optimal overall solution to the problem corresponds to the optimal solution to its
          subproblems, then the problem can be solved using a greedy approach.
    
    Advantages of Greedy Approach:
        - The algorithm is easier to describe.
        - This algorithm can perform better than other algorithms (but, not in all cases)
    
    Drawback of Greedy Approach:
        - As mentioned earlier, the greedy algorithm doesn't always produce the optimal solution.
          This is the major disadvantage of the algorithm.
        - For example, suppose we want to find the longest path in the graph below from root to leaf.
          Let's use the greedy algorithm here.
                20
              2     3
            7  10     1
        Greedy Approach:
            1. Let's start with the root node 20. The weight of the right child is 3 and the weight
               of the left child is 2.
            2. Our problem is to find the largest path. And, the optimal solution at the moment is 3.
               So, the greedy algorithm will choose 3.
            3. Finally the weight of an only child of 3 is 1. This gives us our final result.
               20 + 3 + 1 = 24
            However, it is not the optimal solution. There is another path that carries more weight
            (20 + 2 + 10 = 32) as shown in the image below.
            - Therefore, greedy algorithms do not always give an optimal/feasible solution.
        
    Greedy Algorithm:
        1. To being with, the solution set(containing answers) is empty.
        2. At each step, an item is added to the solution set until a solution is reached.
        3. If the solution set is feasible, the current item is kept.
        4. Else, the item is rejected and never considered again.
    
    Example - Greedy Approach:
        Problem: You have to make a change of an amount using the smallest possible number
                    of coins.
        Amount: $18
        
        Available coins are $5, $2, $1.
        There is no limit to the number of each coin you can use.

        Solution:
            1. Create an empty solution-set = {}. Available coins are {5, 2, 1}
            2. We are supposed to find the sum = 18. Let's start with sum = 0.
            3. Always select the coin with the largest value (ie. 5) until the sum > 18.
                (When we select the largest value at each step, we hope to reach the destination
                faster. This concept is called a greedy choice property)
            4. In the first iteration, solution-set = {5} and sum = 5.
            5. In the second iteration, solution-set = {5, 5} and sum = 10
            6. In the third iteration, solution-set = {5, 5, 5} and sum = 15
            7. In the fourth itertaion, solution-set = {5, 5, 5, 2} and sum = 17.
                (We cannot select 5 here because if we do so, sum = 20 which is greater than 18.
                So, we select the 2nd largest item which is 2.)
            8. Similarly, in the fifth iteration, select 1. Now sum = 18 and solution-set = 
                {5, 5, 5, 2, 1}
        
    Different Types of Greedy Algorithm:
        - Selection Sort
        - Knapsack Problem
        - Minimum Spanning tree
        - Single-Source Shortest Path Problem
        - Job Scheduling Problem
        - Prim's Minimal Spanning Tree Algorithm
        - Kruskal's Minimal Spanning Tree Algorithm
        - Dijkstra's Minimal Spanning Tree Algorithm
        - Huffman Coding
        - Ford-Fulkerson Algorithm

====================================================================================================

Ford-Fulkerson Algorithm:
	https://www.programiz.com/dsa/ford-fulkerson-algorithm
	- Ford-Fulkerson algorithm is a greedy approach for calculating the maximum possible flow
	  in a network or a graph.
	- A term, flow network, is used to describe a network of vertices and edges with a source (S)
	  and a sink (T). Each vertex, except S and T, can receive and send an equal amount of
	  stuff through it. S can only send an T can only receive stuff.
	- We can visualize the understanding of the algorithm using a flow of liquid inside a 
	  network of pipes of different capacities. Each pipe has a certain capacity of liquid it can transfer
	  at an instance. For this algorithm, we are going to find how much liquid can be flowed from the
	  source to the sink at an instance using the network.
	
	Terminologies Used:
		Augmenting Path:
			- It is the path available in a flow network.
		Residual Graph:
			- It represents the flow network that has additional possible flow.
		Residual Capacity:
			- It is the capacity of the edge after subtracting the flow from the maximum capacity.
	
	How Ford-Fulkerson Algorithm works?
		The algorithm follows:
			1. Initialize the flow in all edges to 0.
			2. While there is an augmenting path betwen the source and the sink, add this path to the flow.
			3. Update the residual graph.
		- We can also consider reverse-path if required because if we do not consider them,
		  we may never find a maximum flow.
	
	Ford-Fulkerson Example:
		- The flow of all the edges is 0 at the beginning.
		1. Select any arbitrary path from S to T. In this step, we have selected path S-A-B-T.
		   The minimum capacity among the three edges is 2 (B-T).
		   Based on this, update the flow/capacity for each path.

		2. Select another path S-D-C-T. The minimum capacity among these edges is 3 (S-D).
		   Update the capacities according to this.

		3. Now, let us consider the reverse-path B-D as well.
		   Selecting path S-A-B-D-C-T. The minimum residual capacity among the edges is 1 (D-C).
		   Updating the capacities.
		   The capacity for forward and reverse paths are considered separately.
		
		4. Adding all the flows = 2 + 3 + 1 = 6, which is the maximum possible flow on the flow network.
		- Note that if the capacity for any edge is full, then that path cannot be used.
	
	Ford-Fulkerson Applications
		- Water distribution pipeline
		- Bipartite matching problem
		- Circulation with demands

===========================================================================================================

