Tree Data Structure:
    https://www.programiz.com/dsa/trees
    - A tree is a nonolinear hierarchical data structure that consists of nodes connected by edges.

    Why Tree Data Structures?:
        - Other data structures such as arrays, linked lists, stacks, and queues are linear
          data structures that store data sequentially.
        - In order to perform any operation in a linear data structure, the time complexity
          increases with the increase in data size.
        - But, it is not acceptable in today's computational world.
        - Different tree data structures allow quicker and easier access to the data
          as it is a non-linear data structure.
    
    Tree Terminologies:
        Node:
            - A node is an entity that contains a key or value and pointers to its child nodes.
            - The last nodes of each path are called leaf nodes or external nodes that do not
              contain a link/pointer to child nodes.
            - The node having at least a child node is called an internal node.
        Edge:
            - A link between any two nodes.
        Root:
            - It is the topmost node of a tree.
        Height of a Node:
            - The height of a node is the number of edges from the node to the deepest leaf
              (the longest path from the node to a leaf node).   
        Depth of a Node:
            - The depth of a node is the number of edges from the root to the node.
        Height of a Tree:
            - The height of a Tree is the ehight of the root node or the depth of the deepest node
        Degree of a Node:
            - The degree of a node is the total number of branches of that node.
        Forest:
            - A collection of disjoint trees is called a forest.
            - You can create a forest by cutting the root of a tree.
    
    Types of Tree:
        1. Binary Tree
        2. Binary Search Tree
        3. AVL Tree
        4. B-Tree
    
    Tree Traversal:
        - In order to perform any operation on a tree, a specific node must be reached.
        - The tree traversal algorithm helps in visiting a required node in the tree.
    
    Tree Applications:
        - Binary Search Trees(BSTs) are used to quickly check whether an element is
          present in a set or not.
        - Heap is a kind of tree that is used for heap sort.
        - A modified version of a tree called Tries is used in modern routers to
          store routing information.
        - Most popular databases use B-Trees and T-Trees, which are variants of the
          the tree structure we learned above to store their data.
        - Compilers use a syntax tree to validate the syntax of every program you write.

==========================================================================================

Tree Traversal - inorder, preorder, and postorder:
    https://www.programiz.com/dsa/tree-traversal
    - Traversing a tree means visiting every node in the tree.
    - You might for instance, want to add all the avlues in the tree or find the largest one.
    - For all these operations, you will need to visit each node of the tree.
    - Linear data structures liek arrays, stacks, queues, and linked lists ave only one way
      to read the data.
    - But heirarchical data structure like a tree can be traversed in different ways.
    Example:
        - Starting from top, left to right: 1 -> 12 -> 5 -> 6 -> 9
        - Starting from bottom, left to right: 5 -> 6 -> 12 -> 9 -> 1
        - Although this process is somewhat easy, it doesn't respect the heirarchy of the tree,
          only the depth of the nodes.
    - Instead traversal methods that take into account the basic structure of a tree are used.
        struct node {
            int data;
            struct node* left;
            struct node* right;
        }
    - The struct node pointed to by left and right might have other left and right children
      so we should think of them as sub-trees instead of sub-nodes.
    According to this structure, every tree is a combination of
        - A node carrying data
        - Two subtrees
    - Our goal is to visit each node, we need to visit all the nodes in the subtree,
      visit the root node and visit all the nodes in the right subtree as well.
    - Depending on the order in which this is done, there can be three types of traversal.

    Inorder traversal:
        1. First, visit all the nodes in the left subtree
        2. Then the root node
        3. Visit all the nodes in the right subtree.
        inorder(root->left)
        display(root->data)
        inorder(root->right)
    
    Preorder traversal:
        1. Visit root node
        2. Visit all the nodes in the left subtree
        3. Visit all the nodes in the right subtree
        display(root->data)
        preorder(root->left)
        preorder(root->right)

    Postorder traversal:
        1. Visit all the nodes in the left subtree
        2. Visit all the nodes in the right subtree
        3. Visit the root node
        postorder(root->left)
        postorder(root->right)
        display(root->data)
    
====================================================================================

Binary Tree:
	https://www.programiz.com/dsa/binary-tree
    - A binary tree data structure is a tree data structure in which each parent can
        have at most two children.
    - Each binary tree consists of three items:
        - A data item
        - Address of left child
        - Address of right child
	
	Types of Binary Tree:
		1. Full Binary Tree
			- A special type of binary tree in which every
		   	  parent node/internal node has either two or no children.
		
		2. Perfect Binary Tree
			- Every internal node has exactly two child nodes and all the leaf
			  nodes are at the same level.
		
		3. Complete Binary Tree
			- Similar to a full binary tree but with two major differences
			1. Every level must be completely filled
			2. All the leaf elements must lean towards the left
			3. The last leaf element might not have a right sibling
			   i.e. a complete binary tree doesn't have to be a full binary tree
		
		4. Degenerate or Pathological Tree
			- Is the tree having a single child either left or right.
		
		5. Skewed Binary Tree
			- A pathological/degenerate tree in which the tree is either dominated by the
			  left nodes or the right nodes. Thus, there are two types of skewed binary tree:
			  Left-Skewed Binary Tree and Right-Skwered Binary Tree
		
		6. Balanced Binary Tree
			- Difference between the height of the left and the right subtree for each node
			  is either 0 or 1.
	
	Binary Tree Representation:
		- A node of a binary tree is represented by a structure containing a data part
		  and two pointers to other structures of the same type.
			struct node
			{
				int data;
				struct node *left;
				struct node *right;
			};
	
	Binary Tree Example: Find in examples

	Binary Tree Applications:
		- For easy and quick access to data
		- In router algorithms
		- To implement heap data structure
		- Syntax Tree

====================================================================================

Full Binary Tree:
	https://www.programiz.com/dsa/full-binary-tree
	- A special type of binary tree in which every parent node/internal node
	  has either two or no children.
	- Also known as a proper binary tree.

	Full Binary Tree Theorems:
		Let, i = the number of internal nodes
		 	 n = be the total number of nodes
		 	 l = number of leaves
		 	 λ = number of levels
		1. The number of leaves is i + 1
		2. The total number of nodes is 2i + 1
		3. The number of internal nodes is (n - 1) / 2
		4. The number of leaves is (n + 1) / 2
		5. The total number of nodes is 2l - 1
		6. The number of internal nodes is l - 1
		7. The number of leaves is at most 2^(λ - 1)

======================================================================================

Perfect Binary Tree:
	https://www.programiz.com/dsa/perfect-binary-tree
	- A type of binary tree in which every internal node has exactly two child nodes
	  and all the leaf nodes are at the same level.
	- All internal nodes have a degree of 2
	- Recursively, a perfect binary tree can be defined as:
		1. If a single node has no children, it is a perfect binary tree of height h = 0.
		2. If a node has h > 0, it is a perfect binary tree if both of its subtrees are of
		  height h - 1 and are non-overlapping.
	
	Perfect Binary Tree Theorems:
		1. A perfect binary tree of height h has 2^(h + 1) - 1 nodes
		2. A perfect binary tree with n nodes has height log(n + 1) - 1 = Theta(ln(n))
		3. A perfect binary tree of height h has 2^h leaf nodes
		4. The average depth of a node in a perfect binary tree is theta(ln(n))

==========================================================================================

Complete Binary Tree:
	https://www.programiz.com/dsa/complete-binary-tree
	- A binary tree in which all the levels are completely filled except possibly the lowest one
	  , which is filled from the left.
	- Like a full binary tree, but with two major differences:
		1. All the leaf elements must lean towards the left.
		2. The last leaf element might not have a right sibling
		   i.e. a complete binary tree doesn't have to be a full binary tree.
	
	Full Binary Tree vs Complete Binary Tree:

	How a Complete Binary Tree is Created?
		1. Select the first element of the list to be the root node. (no. of elements on level-I: 1)
		2. Put the second element as a left child of the root node and
		   the third element as the right child. (no. of elements on level-II: 2)
		3. Put the next two elements as children of the left node of the second level.
		   Again, put the next two elements as children of the right node of the second level
		   (no. of elements on level-III: 4).
		4. Keep repeating until you reach the last element.
	
	Check Complete Tree: check example files.

	Relationship between array indexes and tree element:
		- Has interesting property to find children and parents of any node.
		- If index of any element is i, the element in the index 2i + 1
		  will become the left child and element in 2i + 2 index will become the right child.
		  	Left child of 1 (index 0)
			= element in (2*0+1) index 
			= element in 1 index 
			= 12


			Right child of 1
			= element in (2*0+2) index
			= element in 2 index 
			= 9

			Similarly,
			Left child of 12 (index 1)
			= element in (2*1+1) index
			= element in 3 index
			= 5

			Right child of 12
			= element in (2*1+2) index
			= element in 4 index
			= 6

		- Also, the parent of any element at index i is given by the lower bound of (i-1)/2.
			Parent of 9 (position 2) 
			= (2-1)/2 
			= ½ 
			= 0.5
			~ 0 index 
			= 1

			Parent of 12 (position 1) 
			= (1-1)/2 
			= 0 index 
			= 1
		- Understand the mapping of array indexes to tree positions is critical to understanding
		  how the Heap Data Structure works and how it is used to implement Heap Sort.
		
		Complete Binary Tree Applications:
			- Heap-based data structures
			- Heap sort

===========================================================================================

Balanced Binary Tree:
	- A balanced binary tree, also referred to as a height-balanced binary tree,
	  is defined as a binary tree in which the height of the left and right subtree of any node
	  differ by not more than 1.
		1. Difference between the left and the right subtree of any node is not more than one
		2. the left subtree is balanced.
		3. the right subtree is balanced.
	- Difference (df) = |height of left child - height of right child|

	Check if Tree is height Balanced: check examples

	Balanced Binary Tree Applications:
		- AVL Tree
		- Balanced Binary Search Tree